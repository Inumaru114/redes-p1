#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()

def ping(conexao, conteudo_bruto):
    parte_relevante = conteudo_bruto.split(b' ', 1)[1]
    resposta = b':servidor PONG servidor :' + parte_relevante.strip() + b'\r\n'
    conexao.enviar(resposta)

def nick(conexao, dados):

    # inválido
    nickAtual = '*'
    if conexao in list(connections.values()):
        nickAtual = list(connections.keys())[list(connections.values()).index(conexao)]

    if not(validar_nome(dados)):
        conexao.enviar((f':server 432 {nickAtual} {dados} :Nickname inválido\r\n').encode('UTF-8'))
        return
    
    # Disponível
    if not dados.lower() in [conn.lower() for conn in connections]:
        if nickAtual == '*':
            conexao.enviar((f':server 001 {dados} :Bem vindo\r\n').encode('UTF-8'))
            conexao.enviar((f':server 422 {dados} :MOTD File is missing\r\n').encode('UTF-8'))
        else:
            conexao.enviar((f':{nickAtual} NICK {dados}\r\n').encode('UTF-8'))
            del connections[nickAtual]
        connections[dados.lower()] = conexao
        return    

    # Indísponível
    else:
        conexao.enviar((f':server 433 {nickAtual} {dados} :Nickname já está em uso\r\n').encode('UTF-8'))
        return

def interpretar_mensagem(conexao, dados_crus):
    segmentos = dados_crus.split(b' ', 1)
    tipo_comando = segmentos[0].decode('utf-8', 'replace').strip().upper()
    
    if tipo_comando == 'PING' and len(segmentos) > 1:
        ping(conexao, dados_crus)

def processar_comando(conexao, mensagem):
    partes = mensagem.split(b' ', 1)
    comando = partes[0].decode('utf-8').upper()
    
    if comando == 'PING':
        responder_ping(conexao, mensagem)

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    conexao.buffer += dados
    
    while b'\r\n' in conexao.buffer:
        mensagem, _, resto = conexao.buffer.partition(b'\r\n')
        conexao.buffer = resto
        
        processar_comando(conexao, mensagem)

def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.buffer = b''  # Cria buffer específico para cada conexão
    conexao.registrar_recebedor(lambda dados: dados_recebidos(conexao, dados))

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
