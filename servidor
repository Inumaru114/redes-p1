#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    user = '*'
    if conexao in list(connections.values()):
        user = list(connections.keys())[list(connections.values()).index(conexao)]

    s = []
    for grp in groups.values():
        if conexao in grp:
            for connection in grp:
                if conexao != connection and not connection in s:
                    s.append(connection)
        if conexao in grp:
            grp.remove(conexao)


    for friend in friends:
        friend.enviar((f':{user} QUIT :Connetcion closer\r\n').encode('UTF-8'))

    print('conexão fechada')
    conexao.fechar()

    del connections[user]

def ping(conexao, conteudo_bruto):
    parte_relevante = conteudo_bruto.split(b' ', 1)[1]
    resposta = b':servidor PONG servidor :' + parte_relevante.strip() + b'\r\n'
    conexao.enviar(resposta)

def nick(conexao, dados):

    # inválido
    nickAtual = '*'
    if conexao in list(connections.values()):
        nickAtual = list(connections.keys())[list(connections.values()).index(conexao)]

    if not(validar_nome(dados)):
        conexao.enviar((f':server 432 {nickAtual} {dados} :Nickname inválido\r\n').encode('UTF-8'))
        return
    
    # Disponível
    if not dados.lower() in [conn.lower() for conn in connections]:
        if nickAtual == '*':
            conexao.enviar((f':server 001 {dados} :Bem vindo\r\n').encode('UTF-8'))
            conexao.enviar((f':server 422 {dados} :MOTD File is missing\r\n').encode('UTF-8'))
        else:
            conexao.enviar((f':{nickAtual} NICK {dados}\r\n').encode('UTF-8'))
            del connections[nickAtual]
        connections[dados.lower()] = conexao
        return    

    # Indísponível
    else:
        conexao.enviar((f':server 433 {nickAtual} {dados} :Nickname já está em uso\r\n').encode('UTF-8'))
        return

def interpretar_mensagem(conexao, dados_crus):
    segmentos = dados_crus.split(b' ', 1)
    tipo_comando = segmentos[0].decode('utf-8', 'replace').strip().upper()
    
    if tipo_comando == 'PING' and len(segmentos) > 1:
        ping(conexao, dados_crus)

def processar_comando(conexao, mensagem):
    partes = mensagem.split(b' ', 1)
    comando = partes[0].decode('utf-8').upper()
    
    if comando == 'PING':
        responder_ping(conexao, mensagem)

def dados_recebidos(conexao, dados):
    if dados == b'':
        print("Sem dados")
        return sair(conexao)
    print(conexao, dados)

    if mensagens.get(conexao) is None:
        mensagens[conexao] = dados
    else:
        mensagens[conexao] += dados

    print(mensagens[conexao].decode('UTF-8').find('\r\n'))
    if mensagens[conexao].decode('UTF-8').find('\r\n') < 0:
        print(mensagens[conexao].decode('UTF-8'))
        return

    bin = mensagens[conexao]
    new = bin.decode('UTF-8')

    #print(new)
    #new = str(dados)[2:-5].split(' ', 1)
        
    while '\r\n' in new:

        comando, new = new.split('\r\n', 1)
        comando = comando.split(' ', 1)

        if comando[0] == 'PING':
            msg = comando[0] + ' ' + comando[1] + '\r\n'
            msg_encode = msg.encode('UTF-8')
            ping(conexao, msg_encode)

        if comando[0] == 'NICK':
            nick(conexao, comando[1])

        if comando[0] == 'PRIVMSG' or comando[0]=='msg':
            print(comando)
            send_message(conexao, comando[1])

        if comando[0] == 'JOIN':
            join_group(conexao, comando[1])

        if comando[0] == 'PART':
            leave_group(conexao, comando[1])

        if comando[0] == 'grps':
            print_users(conexao)

    if(dadosTratados != ''):
        mensagens[conexao] = new.encode("UTF-8")
        return

    del mensagens[conexao]

def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.buffer = b''  # Cria buffer específico para cada conexão
    conexao.registrar_recebedor(lambda dados: dados_recebidos(conexao, dados))

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
connections = dict()
